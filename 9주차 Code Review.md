    - Spring Boot에서 CRUD API를 개발할 때 체크해야 하는 점
        1. 코드 구조와 모듈화: 프로젝트의 코드 구조와 모듈화가 잘 되어 있는지 확인하세요. 패키지, 클래스, 메서드의 명명 규칙과 구성이 일관성을 유지하고, 기능에 따라 모듈을 적절히 분리하고 추상화하는 것이 중요합니다.
        2. 의존성 관리: 의존성 관리를 철저히 검토하세요. 사용하는 라이브러리와 버전이 적절하게 관리되고, 필요하지 않은 의존성이 없는지 확인하세요. 또한, 중복된 의존성이 없도록 관리해야 합니다.
        3. 비즈니스 로직: 비즈니스 로직이 정확하고 효율적으로 구현되었는지 확인하세요. 요구사항을 충족시키고, 코드 중복을 최소화하며, 알고리즘이 최적화되도록 설계되어야 합니다.
        4. 에러 처리와 예외 처리: 적절한 에러 처리와 예외 처리를 수행하는지 확인하세요. 예외 상황에 대한 적절한 로깅과 사용자에게 명확한 오류 메시지를 제공하는 것이 중요합니다.
        5. 데이터베이스 관련 코드: 데이터베이스 접근과 관련된 코드를 검토하세요. 쿼리의 효율성과 보안, 트랜잭션 처리 등을 고려해야 합니다. ORM 도구를 사용할 경우, 엔티티 매핑과 관련된 사항을 확인하세요.
        6. 코드 스타일과 일관성: 코딩 스타일과 일관성을 유지하는지 확인하세요. 가독성을 높이기 위해 들여쓰기, 공백, 주석 등을 적절히 사용하는 것이 좋습니다.
        7. 로깅과 디버깅: 로깅과 디버깅 기능을 적절히 활용하는지 검토하세요. 로깅 레벨을 적절하게 설정하고, 디버깅 시 도움이 되는 정보를 로그에 기록해야 합니다.
        8. 보안: 보안 관련 사안을 고려하세요. 사용자 입력 값의 검증과 이를 통한 취약점을 방지하는 방어적인 코딩을 수행하세요. 비밀번호 저장 및 전송에 대한 보안 기준을 준수하고, 인증 및 권한 부여를 적절히 구현하세요.
        9. 세션 및 인증 관리: 세션 및 인증 관리 방식을 검토하세요. 사용자 세션의 유지, 인증 및 권한 부여에 대한 처리를 적절히 구현해야 합니다.
    - REST API 설계 체크사항
        1. 명확하고 직관적인 구조: API의 URL은 명확하고 직관적인 구조를 가져야 합니다. URL은 리소스를 나타내므로 각 엔드포인트가 어떤 리소스를 나타내는지 명확하게 표현되어야 합니다.
            - /users: 사용자 리소스에 대한 엔드포인트
            - /products: 제품 리소스에 대한 엔드포인트
        2. 복수형 명사 사용: 리소스는 복수형 명사로 표현하는 것이 일반적입니다. 이는 API의 일관성과 직관성을 높여줍니다.
            - /users: 단일 사용자를 나타내는 것보다 여러 사용자를 나타내는 것이 좋습니다.
        3. 중첩된 리소스: 필요한 경우 중첩된 리소스를 사용하여 복잡한 데이터 관계를 표현할 수 있습니다. 이는 리소스 간의 계층 구조를 나타내는 데 도움이 됩니다. 이때, 중첩이 너무 과다하게 되지 않도록 설계 하는게 좋습니다.
            - /users/{userId}/orders: 특정 사용자의 주문 목록을 나타내는 엔드포인트
        4. 필터링, 페이징, 정렬: 필요한 경우 쿼리 매개변수를 사용하여 데이터를 필터링, 페이징 및 정렬할 수 있는 기능을 제공할 수 있습니다. 이는 대량의 데이터를 다루는 경우 유용합니다.
            - /products?category=electronics: 카테고리가 "electronics"인 제품 목록을 필터링하는 엔드포인트
            - /users?page=2&limit=10: 두 번째 페이지에 표시되는 10개의 사용자 목록을 반환하는 엔드포인트
        5. 버전 관리: 필요한 경우 API의 버전 관리를 위해 URL에 버전 번호를 포함시킬 수 있습니다. 이는 API의 호환성을 유지하고 업데이트 및 변화에 대응하는 데 도움이 됩니다.
            - /v1/users: 버전 1의 사용자 리소스에 대한 엔드포인트
            - /v2/users: 버전 2의 사용자 리소스에 대한 엔드포인트
        6. 의미 있는 단어 사용: URL에는 의미 있는 단어를 사용하여 리소스와 관련된 정보를 전달하는 것이 좋습니다. 이는 API의 가독성과 이해도를 높여줍니다.
            - /products/{productId}: 특정 제품의 상세 정보를 나타내는 엔드포인트
    - Spring Boot에서 Thymeleaf 사용하기
        1. 라이브러리와 의존성 설정: Thymeleaf를 사용하기 위해서는 관련 라이브러리를 프로젝트에 추가해야 합니다. Maven이나 Gradle을 사용하여 `spring-boot-starter-thymeleaf` 의존성을 추가해야 합니다.
        2. 캐싱 설정: Thymeleaf로 개발된 화면을 수정할 때 마다 프로젝트를 재시작해야하는 문제를 해결하기 위해, `application.properties` 파일에 `spring.thymeleaf.cache=false` 설정을 추가하여 캐싱을 비활성화할 수 있습니다.
        3. 데이터 바인딩: Thymeleaf는 `th:text`, `th:value`, `th:placeholder` 등의 속성을 통해 데이터 바인딩을 지원합니다. 그러나 `th:utext` 속성은 HTML 태그를 escape 처리하지 않기 때문에 보안에 취약할 수 있으며, 이 점에 주의해야 합니다.
        4. Getter 메서드: 객체의 속성 값을 Thymeleaf 템플릿에서 사용하려면 해당 객체의 클래스에 getter 메서드가 정의되어 있어야 합니다.
        5. 프래그먼트와 레이아웃: Thymeleaf 프래그먼트를 사용하여 재사용 가능한 레이아웃 및 구성 요소를 만들 수 있습니다. 예를 들어, 모든 페이지에 동일한 푸터를 표시하려면 Thymeleaf 프래그먼트를 사용할 수 있습니다.
    - Docker에서 Spring Boot 애플리케이션 실행하기
        1. 기본 이미지 선택:
            - `openjdk`나 `adoptopenjdk`와 같은 공식 Java 베이스 이미지를 사용하세요.
            - 필요한 Java 버전을 명시하세요. 예: `openjdk:11-jre-slim`
        2. 단계별 빌드 최적화:
            - Maven 또는 Gradle 종속성들은 자주 변경되지 않으므로, 종속성을 먼저 복사하고 빌드하여 이후의 단계에서 캐싱을 효율적으로 사용할 수 있도록 Dockerfile을 구성하세요.
        3. JAR 파일 복사:
            - `target` 또는 `build` 디렉터리에서 생성된 실행 가능한 JAR 파일만 이미지에 복사하세요.
        4. 애플리케이션 실행:
            - `CMD` 명령어를 사용하여 Spring Boot 애플리케이션을 실행하세요. 예: `CMD ["java", "-jar", "app.jar"]`
        5. 환경 변수:
            - 필요한 경우, `ENV` 명령어를 사용하여 환경 변수를 설정하세요.
        6. 미니멀한 이미지 크기:
            - 가능하다면 `slim`이나 `alpine` 버전의 베이스 이미지를 사용하여 최종 이미지의 크기를 최소화하세요.
        7. 보안:
            - `root` 사용자로 애플리케이션을 실행하는 대신, 새 사용자를 만들고 그 사용자로 애플리케이션을 실행하는 것을 고려하세요.
            - 예:

                ```docker
                RUN addgroup -S appgroup && adduser -S appuser -G appgroup
                USER appuser
                ```

        8. 포트 열기:
            - Spring Boot 애플리케이션에서 사용하는 포트를 `EXPOSE` 명령어로 명시하세요.
                - 예: `EXPOSE 8080`
    - Dockerfile 최적화
        1. Multi-Stage Build 사용:
            - 빌드 도구나 중간 객체 파일과 같은 불필요한 파일을 최종 이미지에서 제외하기 위해 Multi-Stage Build를 사용합니다.
            - 예를 들어, 컴파일러와 라이브러리를 설치하고 코드를 빌드한 다음, 그 결과만을 더 가벼운 이미지에 복사합니다.
        2. .dockerignore 사용:
            - `.dockerignore` 파일을 사용하여 불필요한 파일 및 디렉토리를 이미지 빌드에서 제외합니다.
        3. 명령어 체이닝:
            - Docker는 `RUN`, `COPY` 및 `ADD` 명령어를 실행할 때마다 새로운 레이어를 생성합니다.
            - 가능한 경우 명령어를 체인으로 연결하여 레이어 수를 줄입니다.

                ```docker
                RUN apt-get update && apt-get install -y \
                    package1 \
                    package2 \
                    package3
                ```

        4. 불필요한 패키지 제거:
            - 설치 후 불필요한 패키지나 캐시 파일을 삭제합니다.

                ```docker
                RUN apt-get install -y package1 && apt-get clean && rm -rf /var/lib/apt/lists/*
                ```

        5. 베이스 이미지 최적화:
            - 가능한 가장 가벼운 베이스 이미지를 사용하세요. 예를 들어, `alpine` 버전은 작은 크기의 이미지를 제공합니다.
        6. ADD 대신 COPY 사용:
            - 파일이나 디렉토리만 복사하는 경우 `COPY` 명령어를 사용합니다. `ADD`는 URL을 지원하고 자동으로 tar 압축 해제 기능이 있어, 예상치 않은 동작을 일으킬 수 있습니다.
        7. 애플리케이션 사용자 설정:
            - 컨테이너 내에서 애플리케이션을 `root` 사용자로 실행하는 것은 보안상 좋지 않습니다.
            - 대신, 컨테이너 내에 새로운 사용자를 생성하고 그 사용자로 애플리케이션을 실행하세요.
        8. 불변성 유지:
            - 동일한 Dockerfile로 동일한 결과의 이미지를 항상 생성하는 것이 좋습니다. 이를 위해 특정 버전의 패키지나 애플리케이션을 지정하세요.
        9. 레이어 재사용 최적화:
            - 빈번하게 변경되는 명령어나 파일은 Dockerfile의 마지막 부분에 위치시키세요. 이렇게 하면 덜 자주 변경되는 레이어의 캐시를 최대한 활용할 수 있습니다.